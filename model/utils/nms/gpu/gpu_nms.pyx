import numpy as np
cimport numpy as np
np.import_array()


assert sizeof(int) == sizeof(np.int32_t)
assert sizeof(float) == sizeof(np.float32_t)

cdef extern from "gpu_nms.hpp":
    void nms(int *keep, const float *boxes, int n, int m, int max_out, float thresh, int *num_out, int device_id)

def gpu_nms(np.ndarray[float, ndim=2] dets, 
            np.ndarray[float, ndim=1] scores, 
            np.int32_t max_out, 
            float thresh, 
            float score_thresh=0., 
            np.int32_t device_id=0):
    """
    NMS function Cython wrapper.

    Inputs:
    - dets, np.ndarray with shape(n, 4), (x1, y1, x2, y2)detected bounding boxes
    - scores, np.ndarray with shape(n, ), scores to each bbox
    - max_out, maximum number of output generated by nms
    - thresh, nms threshould
    - score_thresh, discard bbox with score below score_thresh(default 0)
    
    Outputs:
    - keep, int, a list of indexes of bouding boxes and scores.
    """
    cdef np.ndarray[int, ndim=1] order = scores.argsort().astype(int)[::-1]
    if score_thresh > 0:
        for _i in range(order.shape[0]):
            if scores[order[_i]] < score_thresh:
                order = order[:_i]
                if _i == 0: return []
                break

    cdef np.ndarray[float, ndim=2, mode='c'] sorted_dets = dets[order, :]
    cdef int n = sorted_dets.shape[0]
    cdef int m = sorted_dets.shape[1] # m = 4
    cdef np.ndarray[int, ndim=1, mode='c'] keep = np.zeros(n, dtype=int)
    cdef int num_out

    nms(&keep[0], &sorted_dets[0, 0], n, m, max_out, thresh, &num_out, device_id)

    return list(order[keep[:num_out]] )   
